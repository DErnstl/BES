gcc -DDEBUG -Wall -pedantic -Werror -Wextra -Wstrict-prototypes -fno-common -g
-O3 -o sender sender.c -lsem182



int WaitForSemaphore() {
        /* Get the semaphore to use dependent on the given type */
        int iSem = (iBinType == MY_SENDER)?iSemIdW:iSemIdR;

        /* Reset the error var */
        errno = 0;

        /* Wait for the Semaphore */
        while (P(iSem) == -1) {
                /* Process can be interrupted, this is no error, so wait until we get a non-error
                 * return value or errno is set to something that is really an error for us
                 */
                if (errno != EINTR) {
                        HANDLEERRORERRNO("Error Waiting on Semaphore: ");
                        return MY_RETURN_ERR;
                }
                /* Reset the error var */
                errno = 0;
        }

        return MY_RETURN_OK;
}

int SignalToSemaphore() {
        /* Get the semaphore to use dependent on the given type */
        int iSem = (iBinType == MY_RECEIVER)?iSemIdW:iSemIdR;

        /* Reset the error var */
        errno = 0;

        /* Signals to the semaphore */
        if (V(iSem) == -1) {
                HANDLEERRORERRNO("Error Signaling to Semaphore: ");
                return MY_RETURN_ERR;
        }

        return MY_RETURN_OK;
}

void WriteToSharedMemory(int iInput) {
        /* Write to the offset position within shared memory */
        *(p_iAdrShmem+iShmPos) = iInput;
        /* on reaching the maximum element count of shared memory reset it to 0 -> circlebuffer */
        if(++iShmPos >= iShmElements) iShmPos = 0;
}

int ReadFromSharedMemory() {
        int iPos = iShmPos;
        /* on reaching the maximum element count of shared memory reset it to 0 -> circlebuffer */
        if(++iShmPos >= iShmElements) iShmPos = 0;
        /* read from the offset position within shared memory */
        return *(p_iAdrShmem+iPos);
}


